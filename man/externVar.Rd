% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/externVar.R
\name{externVar}
\alias{externVar}
\title{Estimation of external variable latent class models}
\usage{
externVar(
  model,
  fixed,
  mixture,
  random,
  subject,
  classmb,
  idiag = FALSE,
  nwg = FALSE,
  link = NULL,
  intnodes = NULL,
  epsY = 0.5,
  data,
  longitudinal,
  method,
  varest = "paramBoot",
  M = 200,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  maxiter = 100,
  posfix,
  verbose = FALSE,
  nproc = 1
)
}
\arguments{
\item{model}{original latent class structure model from which external variables
must be modeled.}

\item{fixed}{two sided linear formula object for specifying the
fixed-effects on external outcome variable.
The response outcome is on the left of \code{~} and the covariates are separated
by \code{+} on the right of the \code{~}. By default, an intercept is included.}

\item{mixture}{one-sided formula object for the class-specific fixed effects
in the model for the external outcome. Among the list of covariates included in fixed,
the covariates with class-specific regression parameters are entered in
mixture separated by \code{+}. By default, an intercept is included.
If no intercept, \code{-1} should be the first term included.}

\item{random}{an optional one sided linear formula object for specifying the
random-effects on external outcome. By default, no random effect is included.}

\item{subject}{name of the covariate representing the grouping structure.
Even without random effect. By default, the funciton will try to retrieve it
from input model}

\item{classmb}{optional one-sided formula describing the covariates in the
class-membership multinomial logistic model. These are external covariates or
external class predictors in this function.}

\item{idiag}{optional logical for the structure of the variance-covariance
matrix of the random-effects. If \code{FALSE}, a non structured matrix of
variance-covariance is considered (by default). If \code{TRUE} a diagonal
matrix of variance-covariance is considered.}

\item{nwg}{optional logical indicating if the variance-covariance of the
random-effects is class-specific. If \code{FALSE} the variance-covariance
matrix is common over latent classes (by default). If \code{TRUE} a
class-specific proportional parameter multiplies the variance-covariance
matrix in each class (the proportional parameter in the last latent class
equals 1 to ensure identifiability).}

\item{link}{link optional family of link functions to estimate for the external outcome.
Defaults to NULL, corresponding to hlme function}

\item{epsY}{optional definite positive real used to rescale the marker in (0,1)
when the beta link function is used. By default, epsY=0.5.}

\item{data}{Data frame containing the variables named in
\code{fixed}, \code{mixture}, \code{random}, \code{classmb} and \code{subject},
for both the current function arguments and the input models arguments
Check \code{details} to get information on the data structure, especially with
individual external outcomes}

\item{longitudinal}{optional list of longitudinal models of type hlme,
lcmm or multlcmm used to build mpjlcmm input model for "twoStageJoint" method.
By default, the function will try to retrieve it from the input model}

\item{method}{character string representing the method to be used :
only joint likelihood two stage estimation "twoStageJoint" implemented at the moment}

\item{varest}{character string indicating the method used to account for step one
variability when computing the variance estimation.
either "none", "paramBoot" or "calc" ("calc" is implemented for "twoStageJoint"
method only) Defaults to \code{"paramBoot"}}

\item{M}{integer number of parametrical boostrap iterations when varest is "paramBoot".
Default to 200.}

\item{B}{optional but recommanded specification for the initial values for the
parameters. Two options are allowed: (1) a vector of initial values is entered.
(2) nothing is specified. A preliminary analysis involving the
estimation of a standard model is performed to choose initial values.}

\item{convB}{optional threshold for the convergence criterion based on the
parameter stability. By default, convB=0.0001.}

\item{convL}{optional threshold for the convergence criterion based on the
log-likelihood stability. By default, convL=0.0001.}

\item{convG}{optional threshold for the convergence criterion based on the
derivatives. By default, convG=0.0001.}

\item{maxiter}{optional maximum number of iterations for the Marquardt
iterative algorithm. Defaults to 100}

\item{posfix}{Optional vector specifying the indices in vector B of the
parameters that should not be estimated. Default to NULL, all external parameters are
estimated.}

\item{verbose}{logical indicating whether information about computation should be
reported. Default to FALSE.}

\item{nproc}{the number cores for parallel computation. Default to 1 (sequential mode).}
}
\description{
This function allows to model external variables in relationship with previously modeled
latent class structures, either external outcomes or external class predictors.
The joint likelihood, for both external class predictors and external outcome
of the class. It returns a model object frome one of the lcmm package model classes.
}
\details{
A. DATA STRUCTURE

The \code{data} argument must follow specific structure for individual variables,
aka variables with a unique constant value for each subject. For an individual variable
given as external outcome, data value must be present only once per subject.
For an individual variable given as external class predictor,
data values must be present for each

B. VARIANCE ESTIMATION

Not taking into account first stage variance with specifing \code{"none"} may lead to
underestimation of the final variance, even though it is much quicker.
With big models it is recommended used variance estimation method \code{"none"} first before using
method \code{"paramBoot"} with parameter \code{"B"} being given the resulting estimates values
}
\examples{

\dontrun{
# Example with hlme input model
mMMSE1_1 <- hlme(MMSE~age65+I(age65^2)+CEP,
                 random=~age65+I(age65^2),
                 subject="ID",
                 data=paquid)
mMMSE2_1 <- hlme(MMSE~age65+I(age65^2)+CEP,
                 random=~age65+I(age65^2),
                 subject="ID",
                 data=paquid,
                 ng=2,
                 mixture=~age65+I(age65^2),
                 B=random(mMMSE1_1))

modPlusCESDnone = externVar(mMMSE2_1,
                            fixed = CESD~age65+I(age65^2)+male,
                            random = ~age65+I(age65^2),
                            mixture = ~age65+I(age65^2),
                            subject="ID",
                            data=paquid,
                            verbose = T,
                            varest = "none",
                            method = "twoStageJoint",
                            B = c(7.8, 6.5, -0.3, 6, 0.8, -0.5, -2.5, 74, -64, 106, 16, -29, 9, 5.4))

modPlusCESDboot = externVar(mMMSE2_1,
                            fixed = CESD~age65+I(age65^2)+male,
                            random = ~age65+I(age65^2),
                            mixture = ~age65+I(age65^2),
                            subject="ID",
                            data=paquid,
                            verbose = T,
                            varest = "paramBoot",
                            M = 10,
                            method = "twoStageJoint",
                            B = c(7.8, 6.5, -0.3, 6, 0.8, -0.5, -2.5, 74, -64, 106, 16, -29, 9, 5.4))

modPlusCESDcalc = externVar(mMMSE2_1,
                            fixed = CESD~age65+I(age65^2)+male,
                            random = ~age65+I(age65^2),
                            mixture = ~age65+I(age65^2),
                            subject="ID",
                            data=paquid,
                            verbose = T,
                            varest = "calc",
                            method = "twoStageJoint",
                            B = c(7.8, 6.5, -0.3, 6, 0.8, -0.5, -2.5, 74, -64, 106, 16, -29, 9, 5.4))
                            
summary(modPlusCESDnone)
summary(modPlusCESDboot)
summary(modPlusCESDcalc)

# Example with Jointlcmm input model
m1 <- Jointlcmm(fixed= Ydep1~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
random=~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
subject='ID',
survival = Surv(Tevent,Event)~ X1+X2,
hazard="Weibull",
hazardtype="Specific",
ng=1,
data=data_lcmm)
m2 <- Jointlcmm(fixed= Ydep1~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                mixture=~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                random=~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                subject='ID',
                survival = Surv(Tevent,Event)~X1+mixture(X2),
                hazard=c("Weibull", "Weibull"),
                hazardtype=c("Specific", "Specific"),
                ng=2,
                data=data_lcmm,
                B=m1)

m2plusY2none = externVar(m2,
                         method = "twoStageJoint",
                         fixed = Ydep2~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         random = ~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         mixture=~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         subject='ID',
                         idiag = TRUE,
                         varest = "none",
                         data=data_lcmm)
m2plusY2boot = externVar(m2,
                         method = "twoStageJoint",
                         fixed = Ydep2~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         random = ~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         mixture=~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         subject='ID',
                         idiag = TRUE,
                         varest = "paramBoot",
                         M = 10,
                         data=data_lcmm,
                         B = m2plusY2none$best[-m2plusY2none$call$posfix])
m2plusY2calc = externVar(m2,
                         method = "twoStageJoint",
                         fixed = Ydep2~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         random = ~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         mixture=~ns(Time, knots = c(1), Boundary.knots = c(0.2, 2.1)),
                         subject='ID',
                         idiag = TRUE,
                         varest = "calc",
                         data=data_lcmm,
                         B = m2plusY2none$best[-m2plusY2none$call$posfix])
summary(m2plusY2none)
summary(m2plusY2boot)
summary(m2plusY2calc)
}


}
